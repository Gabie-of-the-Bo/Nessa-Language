module range [1.0]

class Range {
    start: Number;
    current: Number;
    end: Number;
}

fn iterator(it: Range) -> Range {
    return *it;
}

fn next(it: &&Range) -> Number {
    let curr: &&Number = it.current();
    curr.inc();

    return *curr;
}

fn is_consumed(it: &&Range) -> Bool {
    return it.current() >= it.end();
}

fn range(from: Number, to: Number) -> Range {
    return Range(*from, *from, *to);
}

fn irange(from: Number, to: Number) -> Range {
    return Range(*from, *from, *to + 1);
}

binary op "=>" (10000);

op (from: Number) => (to: Number) -> Range {
    return range(*from, *to);
}
